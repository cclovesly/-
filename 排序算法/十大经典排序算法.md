

## 十大经典排序算法

[TOC]

+ 使用c++、java来描述

+ 开发环境 ：vs2019、idea

+ 算法核心思想

+ 代码实现

  ## 分类

+ 比较类

  + 交换类
    + 冒泡排序
    + 快速排序

  + 插入类
    + 插入排序
    + 希尔排序

  + 选择类
    + 选择排序
    + 堆排序
  + 归并类
    + 归并排序



+ 非比较类
  + 分配类
    + 计数排序
    + 基数排序
    + 堆排序

## 冒泡排序

它是基于交换的排序。每一轮将序列中的最大值放到序列的尾部。

**c++**

```c++
//优化前
//冒泡排序实现
void bubsort(int arr[], int length) {
	while (length--)
	{
		for (int i = 0; i < length; i++) {
			//数组中后一位比前以为小的往前移动
			if (arr[i + 1] < arr[i]) {
				int temp = arr[i + 1];
				arr[i + 1] = arr[i];
				arr[i] = temp;
			}
		}
	}
}
//优化后
//冒泡排序实现
void bubsort(int arr[], int length) {
	int flag = 1;
	while (length-- && flag)
	{
		flag = 0;
		for (int i = 0; i < length; i++) {
			//数组中后一位比前以为小的往前移动
			if (arr[i + 1] < arr[i]) {
				flag = 1;
				int temp = arr[i + 1];
				arr[i + 1] = arr[i];
				arr[i] = temp;
			}
		}
	}
}
```

优化后的冒泡排序比优化前的冒泡排序效率更高的原因是：**当在序列中找到所有的最大值之前就以及将序列排好序时，直接结束函数**；

```c++
//源代码
#include <iostream>
#include <bits/stdc++.h>
#define MAXSIZE 10
using namespace std;

//随机生成20以内的数
void initArr(int arr[],int length) {
	for (int i = 0; i < length; i++) {
		arr[i] = rand() % 20;
	}
}

//打印数组
void showArr(int arr[], int length) {
	for (int i = 0; i < length; i++) {
		cout << arr[i] << " ";
	}
	cout << endl<< "---------------------------";
}

//冒泡排序实现
//flag为true或false
void bubsort(int arr[], int length) {
	int flag = 1;
	while (length-- && flag)
	{
		flag = 0;
		for (int i = 0; i < length; i++) {
			//数组中后一位比前以为小的往前移动
			if (arr[i + 1] < arr[i]) {
				flag = 1;
				int temp = arr[i + 1];
				arr[i + 1] = arr[i];
				arr[i] = temp;
			}
		}
	}
}

int main() {
	srand((unsigned int)time(NULL));
	int arr[MAXSIZE];
	//随机生成数组
	initArr(arr, MAXSIZE);
	//打印数组
	cout << "排序前的数组:";
	showArr(arr, MAXSIZE);
	cout << endl;
	//冒泡排序
	bubsort(arr, MAXSIZE);
	//排序后的数组
	cout << "排序后的数组:";
	showArr(arr, MAXSIZE);
	return 0;
}
```

**java**

```java
//冒泡排序实现
public static void bubSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换 array[j] 和 array[j+1]
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
```

```java
//源代码
//java中随机生成数组的库
import java.util.Random;

public class bobsort {
    public static void main(String[] args) {
        int arraySize = 10; // 定义数组大小
        int[] randomArr = generateRandomArr(arraySize, 1, 20); // 生成随机数组
        printArr(randomArr); // 打印原始数组
        bubSort(randomArr); // 冒泡排序
        printArr(randomArr); // 打印排序后的数组
    }

    // 生成随机数组
    public static int[] generateRandomArr(int size, int min, int max) {
        Random random = new Random();
        int[] arr = new int[size];
        for (int i = 0; i < size; i++) {
            arr[i] = random.nextInt((max - min) + 1) + min;
        }
        return arr;
    }

    // 冒泡排序
    public static void bubSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换 array[j] 和 array[j+1]
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    // 打印数组
    public static void printArr(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}
```



## 选择排序

选择排序的基本思想时冒泡排序。从数组的头元素向后找到最小的元素，与头元素交换，依次找到后面最小的值进行排序,每一轮找到序列中的最小值后与第一个元素交换，以此类推。

**c++**

```c++
//选择排序实现
void selectsort(int arr[],int length) {
	for (int i = 0; i < length; i++) {
		int k = i;
		for (int j = i + 1; j < length; j++) {
			if (arr[j] < arr[k]) {
				k = j;
			}
		}
		int temp = arr[i];
		arr[i] = arr[k];
		arr[k] = temp;
	}
}
```

**java**

```java
  // 选择排序
    public static void selectSort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            // 交换找到的最小元素和当前i位置的元素
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }
```



## 插入排序

将一个数插入一个有序的序列里，这个数从有序数列最大的开始比较依次向前比交，依次交换

插入排序的优点：

​		当原始序列已经基本有序时再将一个新的数据插入进来比较方便，也比较高效率。

**c++**

```c++
// 插入排序实现  
void insertsort(int arr[], int length) {
	for (int i = 1; i < length; i++) {
		int key = arr[i];
		int j = i - 1;

		// 将元素arr[i]插入到已排序的序列arr[0..i-1]中  
		while (j >= 0 && arr[j] > key) {
			arr[j + 1] = arr[j];
			j--;
		}
		arr[j + 1] = key;
	}
}

//插入新的元素
void insertElement(int arr[], int length, int newElement) {
	int i;
	for (i = length - 1; (i >= 0 && arr[i] > newElement); i--) {
		arr[i + 1] = arr[i]; // 将元素向后移动  
	}
	arr[i + 1] = newElement; // 插入新元素  

	// 注意：由于数组大小固定，这里的“插入”实际上是覆盖了数组的最后一个元素。  
	// 在实际应用中，您可能需要重新分配数组的大小来真正插入一个新元素。  
}
```

```c++
//源代码
#include <iostream>
#include <bits/stdc++.h>
#define MAXSIZE 10
int count;
using namespace std;

//随机生成20以内的数
void initArr(int arr[],int length) {
	for (int i = 0; i < length; i++) {
		arr[i] = rand() % 20;
	}
}

//打印数组
void showArr(int arr[], int length) {
	for (int i = 0; i < length; i++) {
		cout << arr[i] << " ";
	}
	cout << endl<< "---------------------------";
}


// 插入排序实现  
void insertsort(int arr[], int length) {
	for (int i = 1; i < length; i++) {
		int key = arr[i];
		int j = i - 1;

		// 将元素arr[i]插入到已排序的序列arr[0..i-1]中  
		while (j >= 0 && arr[j] > key) {
			arr[j + 1] = arr[j];
			j--;
		}
		arr[j + 1] = key;
	}
}

//插入新的元素
void insertElement(int arr[], int length, int newElement) {
	int i;
	for (i = length - 1; (i >= 0 && arr[i] > newElement); i--) {
		arr[i + 1] = arr[i]; // 将元素向后移动  
	}
	arr[i + 1] = newElement; // 插入新元素  

	// 注意：由于数组大小固定，这里的“插入”实际上是覆盖了数组的最后一个元素。  
	// 在实际应用中，您可能需要重新分配数组的大小来真正插入一个新元素。  
}

int main() {
	srand((unsigned int)time(NULL));
	int arr[MAXSIZE];
	//随机生成数组
	initArr(arr, MAXSIZE);
	//打印数组
	cout << "排序前的数组:";
	showArr(arr, MAXSIZE);
	cout << endl;
	//排序后的数组
	cout << "排序后的数组:";
	showArr(arr, MAXSIZE);
	// 模拟插入一个新元素（这里我们假设新元素是5）  
	int newElement = 5; // 新元素值  
	insertElement(arr, MAXSIZE - 1, newElement); // 在已排序的数组中“插入”新元素  

	// 显示插入新元素后的数组  
	cout << "插入新元素后的数组:";
	showArr(arr, MAXSIZE); // 显示全部，包括新插入的元素（实际上是移动了所有元素来模拟的）
	return 0;
}
```

**java**

```java
//插入排序实现
void sort(int arr[]) {
        int n = arr.length;
        for (int i = 1; i < n; ++i) {
            int key = arr[i];
            int j = i - 1;

            // 将大于key的元素向后移动
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            // 找到key的位置并插入
            arr[j + 1] = key;
        }
    }
```

```java
//源代码
public class insertsort {
    void sort(int arr[]) {
        int n = arr.length;
        for (int i = 1; i < n; ++i) {
            int key = arr[i];
            int j = i - 1;

            // 将大于key的元素向后移动
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            // 找到key的位置并插入
            arr[j + 1] = key;
        }
    }

    // 测试插入排序
    public static void main(String args[]) {
        insertsort ob = new insertsort();
        int arr[] = {12, 11, 13, 5, 6};
        ob.sort(arr);
        System.out.println("排序后的数组：");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}
```



## 希尔排序

**优化版的插入排序**：

​	在与序列中元素相比较时，与多个元素进行比较，将序列中最小的拿出来进行排序（优化了步长**↑**，插入排序的步长为1，而希尔排序的步长可以很大，最后逐渐减少到1）

**c++**

```c++
//优化前
//希尔排序
void shellsort(int arr[], int length) {
    /*
    //让h更接近与步长t
    int h=1;
    int t=length/3;
    while(h<t){
    	h=3*h+1;
    }
    */
    /* h为步长(希尔排序步长一般为length/2,步长的取值能
    *  够影响希尔排序的时间复杂度,这里为了简单处理定为4)
    */
	int h = 4;
	while (h>=1)
	{
		for (int i = h; i < length; i++) {
			for (int j = i; j >= h && arr[j] < arr[j - h]; j--) {
				int temp = arr[j];
				arr[j] = arr[j - h];
				arr[j - h] = temp;
			}
		}
		h /= 2;//  h/=3;
	}
}

//优化后
void shellsort(int arr[], int length) {
	//让h更接近于t
	int h = 1;
	int t = length / 3;
	while (h < t) {
		h = 3 * h + 1;
	}
	while (h >= 1)
	{
		for (int i = h; i < length; i++) {
			for (int j = i; j >= h && arr[j] < arr[j - h]; j--) {
				int temp = arr[j];
				arr[j] = arr[j - h];
				arr[j - h] = temp;
			}
		}
		h /= 3;
	}
}
```

经典的希尔排序：1，4，13，...，3*n+1

**java**

```java
//希尔排序实现
public static void shellsort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }

        int gap = arr.length / 2;
        while (gap > 0) {
            for (int i = gap; i < arr.length; i++) {
                int temp = arr[i];
                int j = i;
                while (j >= gap && arr[j - gap] > temp) {
                    arr[j] = arr[j - gap];
                    j -= gap;
                }
                arr[j] = temp;
            }
            gap /= 2;
        }
    }
```



```java
//源代码
import java.util.Random;

public class shellsort {

    public static void shellsort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }

        int gap = arr.length / 2;
        while (gap > 0) {
            for (int i = gap; i < arr.length; i++) {
                int temp = arr[i];
                int j = i;
                while (j >= gap && arr[j - gap] > temp) {
                    arr[j] = arr[j - gap];
                    j -= gap;
                }
                arr[j] = temp;
            }
            gap /= 2;
        }
    }

    public static int[] generateRandomArr(int size, int minValue, int maxValue) {
        int[] randomArr = new int[size];
        Random random = new Random();

        for (int i = 0; i < size; i++) {
            randomArr[i] = minValue + random.nextInt(maxValue - minValue + 1);
        }
        return randomArr;
    }

    public static void printArr(int[] arr) {
        for (int value : arr) {
            System.out.print(value + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int size = 100; // 数组大小
        int minValue = 1; // 数组元素的最小值
        int maxValue = 100; // 数组元素的最大值

        int[] randomArr = generateRandomArr(size, minValue, maxValue);
        System.out.println("排序前:");
        printArr(randomArr);

        shellsort(randomArr);
        System.out.println("排序后:");
        printArr(randomArr);
    }
}
```



## 快速排序

**冒泡排序的优化版：**

​	核心思想：使用轴，每一轮左右递归后，将轴放置序列中间，使得轴左边的元素比轴小，轴右边的比轴大，当所以的元素递归都结束了就自然排好序了。

**c++**

```c++
//快速排序
void quicksort(int arr[],int left,int right) {
	if (left >= right) {
		return;
	}
	int i = left;
	int j = right;
	int pivot = arr[i];
	while (i<j)
	{
		while (i < j && arr[j] >= pivot)
			j--;
			arr[i] = arr[j];
		while (i<j&&arr[i]<=pivot)
			i++;
			arr[j] = arr[i];
	}
	//当j=i时，轴确定
	arr[i] = pivot;
	quicksort(arr, left, i - 1);
	quicksort(arr, i + 1, right);
}
```

**java**

```java
//快速排序实现
public static void quickSort(int[] arr, int left, int high) {
    if (left < high) {
        int pivotIndex = partition(arr, left, high);
        quickSort(arr, left, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    }
}

private static int partition(int[] arr, int left, int high) {
    // 随机选择一个枢轴索引
    int pivotIndex = left + RANDOM.nextInt(high - left + 1);
    // 将枢轴元素移到子数组的末尾
    swap(arr, pivotIndex, high);
    int pivot = arr[high]; // 现在枢轴是子数组的最后一个元素
    int i = left - 1; // 小于枢轴的元素的索引

    for (int j = left; j <= high - 1; j++) {
        // 如果当前元素小于枢轴，则将其与i指向的元素交换，并增加i
        if (arr[j] < pivot) {
            i++;
            swap(arr, i, j);
        }
    }
    // 将枢轴元素放到正确的位置（即它左边的元素都比它小，右边的元素都比它大）
    swap(arr, i + 1, high);
    return i + 1;
}

private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

```java
//源代码
import java.util.Random;

public class QuickSort {

    private static final Random RANDOM = new Random();

    public static void quickSort(int[] arr, int left, int high) {
        if (left < high) {
            int pivotIndex = partition(arr, left, high);
            quickSort(arr, left, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }

    private static int partition(int[] arr, int left, int high) {
        // 随机选择一个枢轴索引
        int pivotIndex = left + RANDOM.nextInt(high - left + 1);
        // 将枢轴元素移到子数组的末尾
        swap(arr, pivotIndex, high);
        int pivot = arr[high]; // 现在枢轴是子数组的最后一个元素
        int i = left - 1; // 小于枢轴的元素的索引

        for (int j = left; j <= high - 1; j++) {
            // 如果当前元素小于枢轴，则将其与i指向的元素交换，并增加i
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        // 将枢轴元素放到正确的位置（即它左边的元素都比它小，右边的元素都比它大）
        swap(arr, i + 1, high);
        return i + 1;
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static int[] generateRandomArr(int size, int minValue, int maxValue) {
        int[] randomArr = new int[size];
        for (int i = 0; i < size; i++) {
            randomArr[i] = RANDOM.nextInt(maxValue - minValue + 1) + minValue;
        }
        return randomArr;
    }

    public static void printArr(int[] arr) {
        for (int value : arr) {
            System.out.print(value + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int size = 20; // 数组大小
        int minValue = 1; // 数组元素的最小值
        int maxValue = 100; // 数组元素的最大值

        int[] randomArr = generateRandomArr(size, minValue, maxValue);
        System.out.println("排序前的数组:");
        printArr(randomArr);

        quickSort(randomArr, 0, randomArr.length - 1);
        System.out.println("排序后的数组:");
        printArr(randomArr);
    }
}
```





## 归并排序

+ 上半集（有序）

基于分而治之的思想。拿两个已经有序的序列，重新组合成一个新的有序序列。

**c++**

```c++
//归并排序
//默认序列a与序列b都是有序序列
void mergesort(int aArr[], int alen, int bArr[], int blen, int* temp) {
	int i = 0;
	int j = 0;
	int k = 0;
	while (i < alen && j < blen)
	{
        //使用三目运算符使代码更加简洁
		temp[k++] = aArr[i] < bArr[j] ? aArr[i++] : bArr[j++];
	}
	while (i < alen)
	{
		temp[k++] = aArr[i++];
	}
	while (j < blen)
	{
		temp[k++] = bArr[j++];
	}
}

//main函数
int main() {
    //简单定义两个有序序列
    int aArr[5] = {1,3,5,7,9};
	int bArr[3] = { 2,8,10 };
	int temp[8];
    //打印数组
	cout << "排序前的数组:";
    showArr(aArr, 5);
    cout << endl;
	showArr(bArr, 3);
    cout << endl;
    mergesort(aArr, 5, bArr, 3, temp);
    //排序后的数组
	cout << "排序后的数组:";
    showArr(temp, 8);
    return 0;
}
```

**java**

```java
//归并排序 
public static void mergeSort(int[] aArr, int[] bArr, int[] temp) {  
        int i = 0;  
        int j = 0;  
        int k = 0;  
  
        while (i < aArr.length && j < bArr.length) {  
            temp[k++] = aArr[i] < bArr[j] ? aArr[i++] : bArr[j++];  
        }  
  
        while (i < aArr.length) {  
            temp[k++] = aArr[i++];  
        }  
  
        while (j < bArr.length) {  
            temp[k++] = bArr[j++];  
        }  
    }  
```

```java
//完整代码
public class MergeSortExample {  
  
    public static void mergeSort(int[] aArr, int[] bArr, int[] temp) {  
        int i = 0;  
        int j = 0;  
        int k = 0;  
  
        while (i < aArr.length && j < bArr.length) {  
            temp[k++] = aArr[i] < bArr[j] ? aArr[i++] : bArr[j++];  
        }  
  
        while (i < aArr.length) {  
            temp[k++] = aArr[i++];  
        }  
  
        while (j < bArr.length) {  
            temp[k++] = bArr[j++];  
        }  
    }  
  
    public static void showArr(int[] arr) {  
        for (int value : arr) {  
            System.out.print(value + " ");  
        }  
    }  
  
    public static void main(String[] args) {  
        int[] aArr = {1, 3, 5, 7, 9};  
        int[] bArr = {2, 8, 10};  
        // 由于Java中的数组大小是固定的，我们需要预先知道合并后数组的大小  
        int[] temp = new int[aArr.length + bArr.length];  
  
        // 打印数组  
        System.out.print("排序前的数组: ");  
        showArr(aArr);  
        System.out.println();  
        showArr(bArr);  
        System.out.println();  
  
        mergeSort(aArr, bArr, temp);  
  
        // 排序后的数组  
        System.out.print("排序后的数组: ");  
        showArr(temp);  
    }  
}
```



+ 下半集（无序）

  **c++**

  ```c++
  //无序序列，将其拆分开，让其成为有序的多个序列
  void merge(int arr[], int low, int mid, int higth,int *temp) {
  	int i = low;
  	int j = mid + 1;
  	int k = low;
  	while (i<=mid&&j<=higth)
  	{
  		temp[k++] = arr[i] < arr[j] ? arr[i++] : arr[j++];
  	}
  	while (i<=mid){
  		temp[k++] = arr[i++];
  	}
  	while (j <= higth) {
  		temp[k++] = arr[j++];
  	}
  	for (i = low; i <= higth; i++) {
  		arr[i] = temp[i];
  	}
  }
  
  void merge_sort(int arr[], int low, int higth,int *temp) {
  	if (low >= higth) {
  		return;
  	}
  	int mid = low + (higth - low) / 2;//(low+higth)/2;
  	merge_sort(arr, low, mid, temp);
  	merge_sort(arr, mid+1, higth, temp);
  	merge(arr, low, mid, higth, temp);
  }
  
  void mergesort(int arr[],int length){
  	int* temp = new int[length];
  	assert(temp);
  	merge_sort(arr, 0, length - 1, temp);
  	delete[] temp;
  }
  
  //main函数
  int main() {
  	srand((unsigned int)time(NULL));
  	int arr[MAXSIZE];
  	//随机生成数组
  	initArr(arr, MAXSIZE);
      //打印数组
  	cout << "排序前的数组:";
  	showArr(arr, MAXSIZE);
      cout << endl;
  	mergesort(arr, MAXSIZE);
      //排序后的数组
  	cout << "排序后的数组:";
      showArr(arr, MAXSIZE);
      return 0;
  }
  ```

  **java**
  
  ```java
  // 合并两个有序子数组 arr[low..mid] 和 arr[mid+1..high]
      public static void merge(int[] arr, int low, int mid, int high, int[] temp) {
          int i = low;     // 左子数组的起始索引
          int j = mid + 1; // 右子数组的起始索引
          int k = low;     // 临时数组的起始索引
  
          // 合并两个子数组，直到其中一个子数组结束
          while (i <= mid && j <= high) {
              if (arr[i] <= arr[j]) {
                  temp[k++] = arr[i++];
              } else {
                  temp[k++] = arr[j++];
              }
          }
  
          // 复制左子数组的剩余元素（如果有）
          while (i <= mid) {
              temp[k++] = arr[i++];
          }
  
          // 复制右子数组的剩余元素（如果有）
          while (j <= high) {
              temp[k++] = arr[j++];
          }
  
          // 将合并后的数据复制回原数组
          for (i = low; i <= high; i++) {
              arr[i] = temp[i];
          }
      }
  
      // 递归执行归并排序
      public static void mergeSort(int[] arr, int low, int high, int[] temp) {
          if (low < high) {
              int mid = (low + high) / 2; // 找到中间索引
              mergeSort(arr, low, mid, temp); // 对左子数组排序
              mergeSort(arr, mid + 1, high, temp); // 对右子数组排序
              merge(arr, low, mid, high, temp); // 合并两个有序子数组
          }
      }
  ```
  
  ```java
  //完整代码
  import java.util.Random;
  
  public class MergeSort {
  
      // 合并两个有序子数组 arr[low..mid] 和 arr[mid+1..high]  
      public static void merge(int[] arr, int low, int mid, int high, int[] temp) {
          int i = low;     // 左子数组的起始索引  
          int j = mid + 1; // 右子数组的起始索引  
          int k = low;     // 临时数组的起始索引  
  
          // 合并两个子数组，直到其中一个子数组结束  
          while (i <= mid && j <= high) {
              if (arr[i] <= arr[j]) {
                  temp[k++] = arr[i++];
              } else {
                  temp[k++] = arr[j++];
              }
          }
  
          // 复制左子数组的剩余元素（如果有）  
          while (i <= mid) {
              temp[k++] = arr[i++];
          }
  
          // 复制右子数组的剩余元素（如果有）  
          while (j <= high) {
              temp[k++] = arr[j++];
          }
  
          // 将合并后的数据复制回原数组  
          for (i = low; i <= high; i++) {
              arr[i] = temp[i];
          }
      }
  
      // 递归执行归并排序  
      public static void mergeSort(int[] arr, int low, int high, int[] temp) {
          if (low < high) {
              int mid = (low + high) / 2; // 找到中间索引  
              mergeSort(arr, low, mid, temp); // 对左子数组排序  
              mergeSort(arr, mid + 1, high, temp); // 对右子数组排序  
              merge(arr, low, mid, high, temp); // 合并两个有序子数组  
          }
      }
  
      // 主函数，程序的入口点  
      public static void main(String[] args) {
          int arraySize = 10; // 数组大小，可以根据需要调整  
          int maxValue = 100; // 数组元素的最大值，可以根据需要调整  
          int[] arr = new int[arraySize]; // 创建数组  
          int[] temp = new int[arraySize]; // 用于合并的临时数组  
          Random rand = new Random(); // 创建随机数生成器  
  
          // 填充数组为随机数  
          for (int i = 0; i < arraySize; i++) {
              arr[i] = rand.nextInt(maxValue); // 生成0到maxValue-1之间的随机数  
          }
  
          System.out.println("排序前的随机数组:");
          printArray(arr); // 打印未排序的数组  
  
          mergeSort(arr, 0, arr.length - 1, temp); // 对整个数组进行归并排序  
  
          System.out.println("排序后的数组:");
          printArray(arr); // 打印排序后的数组  
      }
  
      // 辅助函数，用于打印数组  
      public static void printArray(int[] arr) {
          for (int i = 0; i < arr.length; i++) {
              System.out.print(arr[i] + " ");
          }
          System.out.println(); // 换行  
      }
  }
  ```
  
  

## 堆排序

在我们去构建堆结构的时候有外堆和内堆。

+ 外堆
  + 需要一段和原来数组长度大小的内存空间，这段内存空间是用来存储堆结构的。
+ 内堆
  + 不需要重新开辟内存，直接在原来的数组上进行排序。

堆结构

本质上是一个完全二叉树。每一个节点的存储都是连续的。

知道当前下标为current。

+ 从0开始计数
  + 左子树-->2*current+1
  + 右子树-->2\*current+2
+ 从1开始计数
  + 左子树-->2*current
  + 右子树-->2\*current+1
+ 大顶堆
  + 父亲的权值比左右子树的权值大。
+ 小顶堆
  + 父亲的权值比左右子树的权值小。

![](C:\Users\hasee\OneDrive\桌面\进阶的码农\c++\算法\排序算法\1707481436759.png)

+ 外堆实现

```c
//堆结构
typedef struct Heap{
    int *root;
    int length;
}Heap;
//入堆
void pushHeap(Heap *heap,int date){}
//出堆
int popHeap(Heap *heap){}
/**伪代码
arr[MAXSIZE];
for(arr){
	pushHeap(heap,arr[i]);
}
for(heap){
	arr[i]=popHeap(heap);
}
*/
```

```c
//堆结构
typedef struct Heap {
	int* root;
	int length;
}Heap;

//初始化堆
Heap* creatHeap(int length) {
	Heap* heap = (Heap*)malloc(sizeof(Heap));
	assert(heap);
	heap->length;
	heap->root = (int*)malloc(sizeof(int) * length);
	assert(heap->root);
	return heap;
}

//入堆
void pushHeap(Heap* heap, int date) {
	int current = heap->length++;
	int parent = current / 2;
	heap->root[current] = date;
	while (parent)
	{
		if (heap->root[current] < heap->root[parent]) {
			swap(heap->root, current, parent);
			current = parent;
			parent = current / 2;
		}
		else {
			break;
		}
	}
}

//出堆
int popHeap(Heap* heap) {
	int val = heap->root[0];
	int current = 0;
	int rchild = 2 * current + 2;
	int small;
	heap->root[0] = heap->root[--heap->length];
	while (rchild<heap->length)
	{
		small = heap->root[rchild - 1] < heap->root[rchild] ? rchild - 1 : rchild;
		if (heap->root[small] < heap->root[current]) {
			swap(heap->root, small, current);
			small = current;
			rchild = current / 2;
		}
		else {
			break;
		}
	}
	return val;
}

//堆排序
void heapsort(int arr[],int length){
    Heap* heap = createHeap(MAXSIZE);
    for (int i = 0; i < MAXSIZE; i++) {
        pushHeap(heap, arr[i]);
    }
    cout << "排序后的数组:";
    for (int i = 0; i < MAXSIZE; i++) {
        arr[i] = popHeap(heap);
    }
}

```



**c++**

+ 使用动态数组

```c++
//入堆
void pushHeap(int* heap, int& size, int data) {
	heap[size] = data;
	int current = size;
	int parent = (current - 1) / 2;
	while (current > 0 && heap[current] < heap[parent]) {
		swap(heap[current], heap[parent]);
		current = parent;
		parent = (current - 1) / 2;
	}
	size++;
}

//出堆
int popHeap(int* heap, int& size) {
	int val = heap[0];
	heap[0] = heap[size - 1];
	size--;
	int current = 0;
	int child = 2 * current + 1;
	while (child < size) {
		if (child + 1 < size && heap[child + 1] < heap[child])
			child++;
		if (heap[child] >= heap[current])
			break;
		swap(heap[child], heap[current]);
		current = child;
		child = 2 * current + 1;
	}
	return val;
}

//堆排序实现
void heapsort(int* arr, int length) {
	int* heap = new int[length];
	int heapSize = 0;
	for (int i = 0; i < length; i++) {
		pushHeap(heap, heapSize, arr[i]);
	}
	for (int i = 0; i < length; i++) {
		arr[i] = popHeap(heap, heapSize);
	}
	delete[] heap;
}
```

```c++
//源代码
#include <iostream>
#include <bits/stdc++.h>
#define MAXSIZE 10
using namespace std;

//入堆
void pushHeap(int* heap, int& size, int data) {
	heap[size] = data;
	int current = size;
	int parent = (current - 1) / 2;
	while (current > 0 && heap[current] < heap[parent]) {
		swap(heap[current], heap[parent]);
		current = parent;
		parent = (current - 1) / 2;
	}
	size++;
}
//出堆
int popHeap(int* heap, int& size) {
	int val = heap[0];
	heap[0] = heap[size - 1];
	size--;
	int current = 0;
	int child = 2 * current + 1;
	while (child < size) {
		if (child + 1 < size && heap[child + 1] < heap[child])
			child++;
		if (heap[child] >= heap[current])
			break;
		swap(heap[child], heap[current]);
		current = child;
		child = 2 * current + 1;
	}
	return val;
}


//随机生成20以内的数
void initArr(int arr[],int length) {
	for (int i = 0; i < length; i++) {
		arr[i] = rand() % 20;
	}
}

//打印数组
void showArr(int arr[], int length) {
	for (int i = 0; i < length; i++) {
		cout << arr[i] << " ";
	}
	cout << endl<< "---------------------------";
}

//堆排序实现
void heapSort(int* arr, int length) {
	int* heap = new int[length];
	int heapSize = 0;
	for (int i = 0; i < length; i++) {
		pushHeap(heap, heapSize, arr[i]);
	}
	for (int i = 0; i < length; i++) {
		arr[i] = popHeap(heap, heapSize);
	}
	delete[] heap;
}

int main() {
	srand((unsigned int)time(NULL));
	int arr[MAXSIZE];
	
	//随机生成数组
	initArr(arr, MAXSIZE);
	//打印数组
	cout << "排序前的数组:";
	showArr(arr, MAXSIZE);
	cout << endl;
	heapSort(arr, MAXSIZE);
	//排序后的数组
	cout << "排序后的数组:";
	showArr(arr, MAXSIZE);
	return 0;
}
```



**java**

```java
 // 入堆
    public static void pushHeap(int[] heap, int size, int data) {
        heap[size] = data;
        int current = size;
        int parent = (current - 1) / 2;
        while (current > 0 && heap[current] > heap[parent]) {
            swap(heap, current, parent);
            current = parent;
            parent = (current - 1) / 2;
        }
        size++;
    }

    // 出堆
    public static int popHeap(int[] heap, int size) {
        int val = heap[0];
        heap[0] = heap[size - 1];
        size--;
        int current = 0;
        int child = 2 * current + 1;
        while (child < size) {
            if (child + 1 < size && heap[child + 1] > heap[child])
                child++;
            if (heap[child] <= heap[current])
                break;
            swap(heap, child, current);
            current = child;
            child = 2 * current + 1;
        }
        return val;
    }
// 堆排序实现
    public static void heapSort(int[] arr) {
        int heapSize = arr.length;
        for (int i = heapSize / 2 - 1; i >= 0; i--) {
            heapify(arr, heapSize, i);
        }
        for (int i = heapSize - 1; i > 0; i--) {
            swap(arr, 0, i);
            heapify(arr, i, 0);
        }
    }

    // 建堆
    public static void heapify(int[] arr, int heapSize, int root) {
        int largest = root;
        int leftChild = 2 * root + 1;
        int rightChild = 2 * root + 2;

        if (leftChild < heapSize && arr[leftChild] > arr[largest]) {
            largest = leftChild;
        }
        if (rightChild < heapSize && arr[rightChild] > arr[largest]) {
            largest = rightChild;
        }
        if (largest != root) {
            swap(arr, root, largest);
            heapify(arr, heapSize, largest);
        }
    }
```

```java
//源代码
import java.util.Arrays;
import java.util.Random;

public class Main {
    public static void main(String[] args) {
        int maxSize = 10;
        int[] arr = new int[maxSize];

        // 随机生成数组
        initArr(arr, maxSize);
        // 打印数组
        System.out.print("排序前的数组: ");
        showArr(arr);
        System.out.println();
        heapSort(arr);
        // 排序后的数组
        System.out.print("排序后的数组: ");
        showArr(arr);
    }

    // 入堆
    public static void pushHeap(int[] heap, int size, int data) {
        heap[size] = data;
        int current = size;
        int parent = (current - 1) / 2;
        while (current > 0 && heap[current] > heap[parent]) {
            swap(heap, current, parent);
            current = parent;
            parent = (current - 1) / 2;
        }
        size++;
    }

    // 出堆
    public static int popHeap(int[] heap, int size) {
        int val = heap[0];
        heap[0] = heap[size - 1];
        size--;
        int current = 0;
        int child = 2 * current + 1;
        while (child < size) {
            if (child + 1 < size && heap[child + 1] > heap[child])
                child++;
            if (heap[child] <= heap[current])
                break;
            swap(heap, child, current);
            current = child;
            child = 2 * current + 1;
        }
        return val;
    }

    // 随机生成20以内的数
    public static void initArr(int[] arr, int length) {
        Random rand = new Random();
        for (int i = 0; i < length; i++) {
            arr[i] = rand.nextInt(20);
        }
    }

    // 打印数组
    public static void showArr(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println("\n---------------------------");
    }

    // 交换数组中两个元素的位置
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // 堆排序实现
    public static void heapSort(int[] arr) {
        int heapSize = arr.length;
        for (int i = heapSize / 2 - 1; i >= 0; i--) {
            heapify(arr, heapSize, i);
        }
        for (int i = heapSize - 1; i > 0; i--) {
            swap(arr, 0, i);
            heapify(arr, i, 0);
        }
    }

    // 建堆
    public static void heapify(int[] arr, int heapSize, int root) {
        int largest = root;
        int leftChild = 2 * root + 1;
        int rightChild = 2 * root + 2;

        if (leftChild < heapSize && arr[leftChild] > arr[largest]) {
            largest = leftChild;
        }
        if (rightChild < heapSize && arr[rightChild] > arr[largest]) {
            largest = rightChild;
        }
        if (largest != root) {
            swap(arr, root, largest);
            heapify(arr, heapSize, largest);
        }
    }
}

```

+ 外堆实现

```c++
// 调整堆
void heapify(int arr[], int n, int i) {
	int largest = i;  // 初始化最大元素为根节点
	int left = 2 * i + 1;  // 左子节点的索引
	int right = 2 * i + 2;  // 右子节点的索引

	// 如果左子节点大于根节点
	if (left < n && arr[left] > arr[largest]) {
		largest = left;
	}

	// 如果右子节点大于当前最大节点
	if (right < n && arr[right] > arr[largest]) {
		largest = right;
	}

	// 如果最大节点不是根节点
	if (largest != i) {
		swap(arr[i], arr[largest]);
		// 递归调整子树
		heapify(arr, n, largest);
	}
}

// 堆排序
void heapSort(int arr[], int n) {
	// 构建最大堆（从最后一个非叶子节点开始）
	for (int i = n / 2 - 1; i >= 0; i--) {
		heapify(arr, n, i);
	}

	// 逐个从堆顶取出元素，放到已排序区间末尾
	for (int i = n - 1; i > 0; i--) {
		swap(arr[0], arr[i]);  // 将堆顶元素（最大值）交换到末尾
		heapify(arr, i, 0);  // 对剩余的元素重新进行堆化操作
	}
}
```



```java
//heapify内堆实现
public static void heapify(int[] arr, int n, int i) {
        int largest = i;  // 初始化最大元素为根节点
        int left = 2 * i + 1;  // 左子节点的索引
        int right = 2 * i + 2;  // 右子节点的索引

        // 如果左子节点大于根节点
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }

        // 如果右子节点大于当前最大节点
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }

        // 如果最大节点不是根节点
        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            // 递归调整子树
            heapify(arr, n, largest);
        }
    }

    // 堆排序
    public static void heapSort(int[] arr) {
        int n = arr.length;

        // 构建最大堆（从最后一个非叶子节点开始）
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }

        // 逐个从堆顶取出元素，放到已排序区间末尾
        for (int i = n - 1; i > 0; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            heapify(arr, i, 0);  // 对剩余的元素重新进行堆化操作
        }
    }
```

```java
//源代码
import java.util.Arrays;
import java.util.Random;

public class HeapSort {
    // 调整堆
    public static void heapify(int[] arr, int n, int i) {
        int largest = i;  // 初始化最大元素为根节点
        int left = 2 * i + 1;  // 左子节点的索引
        int right = 2 * i + 2;  // 右子节点的索引

        // 如果左子节点大于根节点
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }

        // 如果右子节点大于当前最大节点
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }

        // 如果最大节点不是根节点
        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            // 递归调整子树
            heapify(arr, n, largest);
        }
    }

    // 堆排序
    public static void heapSort(int[] arr) {
        int n = arr.length;

        // 构建最大堆（从最后一个非叶子节点开始）
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }

        // 逐个从堆顶取出元素，放到已排序区间末尾
        for (int i = n - 1; i > 0; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            heapify(arr, i, 0);  // 对剩余的元素重新进行堆化操作
        }
    }

    // 打印数组
    public static void showArr(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // 随机生成数组
    public static void iniArr(int[] arr, int minVal, int maxVal) {
        Random random = new Random();

        for (int i = 0; i < arr.length; i++) {
            arr[i] = random.nextInt(maxVal - minVal + 1) + minVal;
        }
    }

    public static void main(String[] args) {
        int size = 10;
        int minVal = 1;
        int maxVal = 100;

        int[] arr = new int[size];

        iniArr(arr, minVal, maxVal);

        // 打印排序前的数组
        System.out.print("排序前的数组: ");
        showArr(arr);
        System.out.println();

        heapSort(arr);

        // 打印排序后的数组
        System.out.print("排序后的数组: ");
        showArr(arr);
    }
}

```



## 计数排序

算法思想：统计原序列的元素，并将元素转换成下标存储与一个临时空间中，然后遍历临时空间把对应的下标放回原序列，当遍历临时空间完成后，原序列就排好序了。（在一个空数组中，对每一个下标进行++操作，遍历数组元素，一直遍历到最大值时，数组排序完成）

**c++**

```c++
//偷懒直接定义临时数组空间
#define N 100
int temp[N];

//计数排序实现
void countsort(int arr[],int length) {
	for (int i = 0; i < length; i++) {
		temp[arr[i]]++;
	}
	for (int i = 0, j = 0; i < N; i++) {
		while (temp[i]--)
		{
			arr[j++] = i;
		}
	}
}
//优化后
//计数排序实现
void countsort(int arr[], int length) {
	int max = arr[0];
	for (int i = 1; i < length; i++) {
		if (arr[i] > max) {
			max = arr[i];
		}
	}
	int* count = (int*)malloc((max + 1) * sizeof(int)); // 动态分配计数数组
	// 初始化计数数组
	for (int i = 0; i <= max; i++) {
		count[i] = 0;
	}
	// 统计每个元素的个数
	for (int i = 0; i < length; i++) {
		count[arr[i]]++;
	}
	// 根据计数数组重新填充原数组
	int index = 0;
	for (int i = 0; i <= max; i++) {
		while (count[i] > 0) {
			arr[index++] = i;
			count[i]--;
		}
	}
	free(count); // 释放动态分配的内存
}
```

+ java

```java
//定义临时数组
package com.text;

import java.util.Arrays;
import java.util.Random;

public class CountSort {
    static final int MAXSIZE = 10;
    static final int N = 100;
    static int[] temp = new int[N];

    public static void initArr(int[] arr) {
        Random rand = new Random();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = rand.nextInt(20);
        }
    }

    public static void showArr(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println("\n---------------------------");
    }

    public static void countsort(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            temp[arr[i]]++;
        }
        for (int i = 0, j = 0; i < N; i++) {
            while (temp[i]-- > 0) {
                arr[j++] = i;
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = new int[MAXSIZE];

        // 随机生成数组
        initArr(arr);
        // 打印数组
        System.out.println("排序前的数组:");
        showArr(arr);
        System.out.println();

        countsort(arr);
        // 排序后的数组
        System.out.println("排序后的数组:");
        showArr(arr);
    }
}
```

```java
//计数排序实现 
public static void countsort(int[] arr) {
        int max = Arrays.stream(arr).max().getAsInt();

        int[] count = new int[max + 1]; // 初始化计数数组

        // 统计每个元素的个数
        for (int num : arr) {
            count[num]++;
        }

        // 根据计数数组重新填充原数组
        int index = 0;
        for (int i = 0; i <= max; i++) {
            while (count[i] > 0) {
                arr[index++] = i;
                count[i]--;
            }
        }
    }


//优化后源码
package com.text;

import java.util.Arrays;
import java.util.Random;

public class CountSort {

    static final int MAXSIZE = 10;

    // 随机生成20以内的数
    public static void initArr(int[] arr) {
        Random rand = new Random();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = rand.nextInt(20);
        }
    }

    // 打印数组
    public static void showArr(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println("\n---------------------------");
    }

    public static void countsort(int[] arr) {
        int max = Arrays.stream(arr).max().getAsInt();

        int[] count = new int[max + 1]; // 初始化计数数组

        // 统计每个元素的个数
        for (int num : arr) {
            count[num]++;
        }

        // 根据计数数组重新填充原数组
        int index = 0;
        for (int i = 0; i <= max; i++) {
            while (count[i] > 0) {
                arr[index++] = i;
                count[i]--;
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = new int[MAXSIZE];

        // 随机生成数组
        initArr(arr);

        // 打印数组
        System.out.print("排序前的数组: ");
        showArr(arr);

        countsort(arr);

        // 排序后的数组
        System.out.print("排序后的数组: ");
        showArr(arr);
    }
}

```



## 基数排序

 核心思想是根据元素的位数来进行排序。 ( **按位排序**： 从低位到高位依次对数据进行排序。 **稳定性** , **桶排序** , **多次排序** ： 基数排序需要对每一位进行排序，通常需要进行多轮排序，直到最高位排序完成。  **合并结果** :经过多次排序后，最终得到有序序列 ).

例子：

154 432 365 251 78 92 640

---------------------------------------------

第一轮（10⁰位）：640 251 92 432 154 365 78

第二轮（10¹位）：432 640 251 154 365 78 92

第三轮（10²位）：78 92 154 251 432 365 640

**c++**

```c++
//基数排序实现
void redixsort(int arr[], int length) {
	int max_num = *max_element(arr, arr + length); // 找到数组中的最大值
	int Temp[10][N]; // 初始化Temp数组
	for (int k = 1; max_num / k > 0; k *= 10) {
		// 动态分配Temp数组的空间
		int* count = new int[10](); // 计数数组，用于记录每个桶中元素的个数
		int* output = new int[length]; // 临时数组，用于存储排序后的结果
		// 将元素分配到Temp数组中
		for (int i = 0; i < length; i++) {
			int pos = (arr[i] / k) % 10;
			Temp[pos][count[pos]++] = arr[i];
		}
		// 从Temp数组中取回元素
		int pos = 0;
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < count[i]; j++) {
				arr[pos++] = Temp[i][j];
			}
		}
		delete[] count;
		delete[] output;
	}
}

```

**java**

```java
package com.text;

import java.util.Arrays;
import java.util.Random;

public class RadixSort {
    static final int MAXSIZE = 10;

    // 随机生成20以内的数
    static void initArr(int[] arr) {
        Random rand = new Random();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = rand.nextInt(20);
        }
    }

    // 打印数组
    static void showArr(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println("\n---------------------------");
    }

    static void redixsort(int[] arr) {
        int max_num = Arrays.stream(arr).max().getAsInt(); // 找到数组中的最大值
        int[][] Temp = new int[10][arr.length]; // 初始化Temp数组
        for (int k = 1; max_num / k > 0; k *= 10) {
            int[] count = new int[10]; // 计数数组，用于记录每个桶中元素的个数

            // 将元素分配到Temp数组中
            for (int i = 0; i < arr.length; i++) {
                int pos = (arr[i] / k) % 10;
                Temp[pos][count[pos]++] = arr[i];
            }

            // 从Temp数组中取回元素
            int pos = 0;
            for (int i = 0; i < 10; i++) {
                for (int j = 0; j < count[i]; j++) {
                    arr[pos++] = Temp[i][j];
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = new int[MAXSIZE];

        // 随机生成数组
        initArr(arr);
        // 打印数组
        System.out.print("排序前的数组: ");
        showArr(arr);
        System.out.println();
        redixsort(arr);
        // 排序后的数组
        System.out.print("排序后的数组: ");
        showArr(arr);
    }
}
```



## 桶排序

 根据元素的值将它们分配到不同的桶中，然后分别对每个桶中的元素进行排序，最后将所有桶中的元素合并得到有序序列。 

1. **确定桶的数量：** 首先确定需要多少个桶来容纳待排序的元素。桶的数量可以根据输入数据的特点和范围来确定。
2. **分配元素到桶中：** 将待排序的元素根据其值分配到对应的桶中。这一步可以使用映射函数将元素映射到桶的索引，确保元素被均匀分布到各个桶中。
3. **对每个桶进行排序：** 对每个非空的桶单独进行排序。可以使用其他排序算法（如插入排序、快速排序等）对每个桶中的元素进行排序。
4. **合并桶中元素：** 最后，将所有桶中的元素按照顺序合并起来，得到最终的有序序列。

**c++**

```c++
//桶排序实现
void bucketsort(int arr[], int length) {
    int max_num = 0; // 初始化最大值为0
    // 计算数组中的最大值
    for (int i = 0; i < length; i++) {
        if (arr[i] > max_num) {
            max_num = arr[i];
        }
    }
    // 动态分配临时数组
    int* Temp = new int[max_num + 1];
    // 初始化Temp数组
    for (int i = 0; i <= max_num; i++) {
        Temp[i] = 0;
    }
    // 统计每个元素出现的次数
    for (int i = 0; i < length; i++) {
        Temp[arr[i]]++;
    }
    // 将排序后的元素放回原数组
    int index = 0;
    for (int i = 0; i <= max_num; i++) {
        while (Temp[i] > 0) {
            arr[index++] = i;
            Temp[i]--;
        }
    }
    // 释放动态分配的内存
    delete[] Temp;
}
```

**java**

```java
//源代码
package com.text;

import java.util.Arrays;
import java.util.Random;

public class BucketSort {
    static final int MAXSIZE = 10;

    // 随机生成20以内的数
    public static void initArr(int[] arr) {
        Random rand = new Random();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = rand.nextInt(20);
        }
    }

    // 打印数组
    public static void showArr(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println("\n---------------------------");
    }

    public static void bucketsort(int[] arr) {
        int max_num = 0; // 初始化最大值为0

        // 计算数组中的最大值
        for (int num : arr) {
            if (num > max_num) {
                max_num = num;
            }
        }

        // 初始化临时数组
        int[] temp = new int[max_num + 1];

        // 统计每个元素出现的次数
        for (int num : arr) {
            temp[num]++;
        }

        // 将排序后的元素放回原数组
        int index = 0;
        for (int i = 0; i <= max_num; i++) {
            while (temp[i] > 0) {
                arr[index++] = i;
                temp[i]--;
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = new int[MAXSIZE];

        // 随机生成数组
        initArr(arr);
        // 打印数组
        System.out.print("排序前的数组:");
        showArr(arr);
        bucketsort(arr);
        // 排序后的数组
        System.out.print("排序后的数组:");
        showArr(arr);
    }
}

```

